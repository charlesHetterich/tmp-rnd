//! Entrypoint macro implementation
//!
//! The `pvm::entrypoint!()` macro generates all contract boilerplate:
//! - Global allocator
//! - Panic handler
//! - `call` and `deploy` entry points
//!
//! It works by referencing markers generated by #[pvm::storage], #[pvm::init], #[pvm::call].

use proc_macro2::TokenStream;
use quote::quote;

pub fn expand(_input: TokenStream) -> TokenStream {
    // The entrypoint macro generates boilerplate that references:
    // - __PVM_INIT_WRAPPER (from #[pvm::init])
    // - __PVM_DISPATCH (from #[pvm::call] - generated as a const array)
    // - Storage type's load/save (from #[pvm::storage])

    quote! {
        // ============================================================
        // PVM Contract Boilerplate (generated by pvm::entrypoint!())
        // ============================================================

        extern crate alloc;

        #[global_allocator]
        static __PVM_ALLOCATOR: pvm::alloc_impl::PvmAllocator = pvm::alloc_impl::PvmAllocator;

        #[cfg(target_arch = "riscv64")]
        #[panic_handler]
        fn __pvm_panic(_info: &core::panic::PanicInfo) -> ! {
            unsafe {
                core::arch::asm!("unimp");
                core::hint::unreachable_unchecked()
            }
        }

        #[cfg(not(target_arch = "riscv64"))]
        #[panic_handler]
        fn __pvm_panic(_info: &core::panic::PanicInfo) -> ! {
            loop {}
        }

        #[polkavm_derive::polkavm_export]
        extern "C" fn deploy() {
            pvm::alloc_impl::reset();
            __pvm_deploy_impl();
        }

        #[polkavm_derive::polkavm_export]
        extern "C" fn call() {
            pvm::alloc_impl::reset();
            __pvm_call_impl();
        }
    }
}
